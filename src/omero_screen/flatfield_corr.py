"""Module to generate flatfield masks for a given plate and upload them to the OMERO server.
The main function, fatfieldcorr, generates flatfield correction masks for each channel in the plate.
The masks are stored in the linked dataset in the Screens project on the OMERO server.
Quality control examples are saved as pdf attachments to the dataset.
The flatfield corr function returns a dictionary with channel names and the corresponding flatfield correction masks.
"""

import logging
import os
import platform
import random
import tempfile
from typing import Any

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import numpy.typing as npt
from ezomero import get_image
from omero.gateway import (
    BlitzGateway,
    DatasetWrapper,
    ImageWrapper,
    MapAnnotationWrapper,
    PlateWrapper,
)
from omero_utils.map_anns import add_map_annotations
from skimage import exposure
from tqdm import tqdm
from typing_extensions import Generator

from omero_screen.aggregator import ImageAggregator

# from omero_screen.general_functions import (
#     add_map_annotation,
#     generate_image,
#     scale_img,
# )
from .metadata_parser import MetadataParser

logger = logging.getLogger("omero-screen")

if platform.system() == "Darwin":
    matplotlib.use(
        "MacOSX"
    )  # avoid matplotlib warning about interactive backend


def flatfieldcorr(
    conn: BlitzGateway, meta_data: MetadataParser, dataset_id: int
) -> dict[str, npt.NDArray[Any]]:
    """
    Fetches or generates flatfield correction masks for given metadata and connection.
    And saves them as an image in the dataset generated by the metadata class.
    Example images are added to the data set as pdf file attachments for quality control.

    Args:
        conn: Connection to OMERO
        meta_data: Metadata object that contains information about the plate, channels, image and dataset.
        dataset_id: ID of the dataset for the flatfield masks

    Returns:
        Dictionary containing flatfield correction masks.
    """
    plate = conn.getObject("Plate", meta_data.plate_id)
    assert plate is not None, "Invalid plate id"
    image_name = f"{meta_data.plate_id}_flatfield_masks"
    dataset = conn.getObject("Dataset", dataset_id)
    assert dataset is not None, "Invalid dataset id"
    image_dict = {}
    image_id = None
    # Loop over each image in the dataset to check if the required image is already present
    for image in dataset.listChildren():
        if image.getName() == image_name:
            image_id = image.getId()
            print(f"Image {image_name} already exists in the dataset.")
            image_dict = load_image_to_dict(conn, image_id)
            break  # stop the loop once the image is found
    # If the image is not already present, generate it
    if image_id is None:
        image_dict = generate_corr_dict(
            conn, plate, meta_data.channel_data, dataset_id
        )
        upload_images(conn, dataset, image_name, image_dict)
        logger.info("Uploaded %s to dataset %s", image_name, dataset.getName())
    # If no flatfield correction masks found, raise an error
    if len(image_dict) == 0:
        raise ValueError("No flatfield correction masks found")
    else:
        print("Flatfield correction masks successfully loaded")
    return image_dict


def upload_images(
    conn: BlitzGateway,
    dataset: DatasetWrapper,
    image_name: str,
    image_dict: dict[str, npt.NDArray[Any]],
) -> None:
    """
    Uploads generated images to OMERO server.

    Args:
        conn: Connection to OMERO.
        dataset: Object representing the dataset to which the images are to be uploaded.
        image_name: Name to be given to the uploaded image.
        image_dict: Dictionary containing channel names and corresponding image arrays.
    """
    array_list = []
    channel_names = list(image_dict.keys())  # get channel names
    channel_number = len(channel_names)  # get number of channels
    for array in image_dict.values():
        # Wrap the array in a generator
        array_list.append(array)

    def plane_gen() -> Generator[npt.NDArray[Any]]:
        """Generator that yields each plane in the array_list"""
        yield from array_list

    # Create the image in the dataset
    image = conn.createImageFromNumpySeq(
        plane_gen(), image_name, 1, channel_number, 1, dataset=dataset
    )
    logger.info("Created image with ID: %s", image.getId())
    # Create a dictionary of channel names
    channel_dict = {
        f"channel_{i}": name for i, name in enumerate(channel_names)
    }
    add_map_annotations(conn, image, channel_dict)


def load_image_to_dict(
    conn: BlitzGateway, image_id: int
) -> dict[str, npt.NDArray[Any]]:
    """
    Loads an image from the OMERO server and converts it to a dictionary with channel names as keys and corresponding image arrays as values.

    Args:
        conn: Connection to OMERO
        image_id: ID of the image to be loaded from the OMERO server.

    Returns:
        Dictionary containing channel names and corresponding image arrays.
    """
    # Fetch the image
    image = conn.getObject("Image", image_id)
    if not image:
        raise ValueError(f"No image found with ID: {image_id}")

    # Retrieve the pixels for the image
    pixels = image.getPrimaryPixels()

    # Initialize the dictionary
    image_dict = {}

    # Fetch annotations attached to the image
    annotations = image.listAnnotations()

    # Filter for MapAnnotations only
    map_anns = [
        ann for ann in annotations if isinstance(ann, MapAnnotationWrapper)
    ]

    # Extract the channel names from the annotations
    for ann in map_anns:
        kv_pairs = ann.getValue()
        for kv in kv_pairs:
            key, value = kv
            if key.startswith("channel"):
                channel_num = int(
                    key.split("_")[-1]
                )  # Assumes channel keys are in the format 'Channel_X'
                # Retrieve the plane corresponding to the current channel
                plane = pixels.getPlane(0, channel_num, 0)  # Assumes Z=0, T=0
                # Add to the dictionary
                image_dict[value] = plane

    return image_dict


def generate_corr_dict(
    conn: BlitzGateway,
    plate: PlateWrapper,
    channels: dict[str, str],
    dataset_id: int,
) -> dict[str, npt.NDArray[Any]]:
    """
    Generates a dictionary of flatfield correction masks for each channel in the plate.

    Args:
        conn: Connection to OMERO
        plate (omero.gateway.PlateWrapper): PlateWrapper object representing the plate.
        channels (dict): Dictionary containing channel names and IDs.
        dataset_id (int): ID of the dataset on the OMERO server to which the image should be attached.

    Returns:
        Dictionary containing channel names and corresponding flatfield correction masks.
    """
    print(
        f"\nAssembling Flatfield Correction Masks for {len(channels)} Channels\n"
    )
    corr_dict = {}
    img_list = random_imgs(plate)
    # # check if images are 4D with z-stacks
    # first_img_id = img_list[0]
    # first_img = conn.getObject("Image", first_img_id)
    # if first_img.getSizeZ() > 1:
    #     logger.info(f"Images are 4D with {first_img.getSizeZ()} z-stacks")
    #     img_list = [parse_mip(img_id, dataset_id, conn) for img_id in img_list]
    for ch, idx in channels.items():
        norm_mask = aggregate_imgs(conn, img_list, int(idx))
        example = gen_example(conn, img_list, int(idx), norm_mask)
        example_fig(conn, example, ch, dataset_id)
        corr_dict[ch] = (
            norm_mask  # associates channel name with flatfield mask
        )
    return {
        k: corr_dict[k]
        for k, v in sorted(channels.items(), key=lambda item: item[1])
    }


def random_imgs(plate: PlateWrapper) -> list[int]:
    """
    Selects a random image from each well in the given plate.

    Args:
        plate: Object representing the plate.

    Returns:
        List of random image IDs from each well in the plate.
    """
    # Get all the wells associated with the plate
    wells = plate.listChildren()
    img_list: list[int] = []
    for well in wells:
        index = well.countWellSample()
        img_list.extend(well.getImage(index).getId() for index in range(index))
    return img_list if len(img_list) <= 100 else random.sample(img_list, 100)


def aggregate_imgs(
    conn: BlitzGateway, img_list: list[int], channel: int
) -> npt.NDArray[Any]:
    """
    Aggregates images in a well for a specified channel and generates correction mask using the Aggregator Module.

    Args:
        conn: Connection to OMERO
        img_list: List of image IDs to aggregate.
        channel: Channel index.

    Returns:
        Flatfield correction mask for the given channel.
    """
    agg = ImageAggregator(60)
    for img_id in tqdm(img_list):
        # Get the image dimensions
        image = conn.getObject("Image", img_id)
        xyzct = [
            image.getSizeX(),
            image.getSizeY(),
            image.getSizeZ(),
            image.getSizeC(),
            image.getSizeT(),
        ]
        # Get random timepoints
        num_images_to_select = min(10, xyzct[-1])
        selected_t = random.sample(range(xyzct[-1]), num_images_to_select)
        axis_lengths = (xyzct[0], xyzct[1], xyzct[2], 1, 1)
        for t in selected_t:
            # Returns: ImageWrapper, ndarray (TZYXC order); crop uses xyzct
            start = (0, 0, 0, channel, t)
            _, image_array = get_image(
                conn, img_id, start_coords=start, axis_lengths=axis_lengths
            )
            if xyzct[2] > 1:
                image_array = np.max(image_array, axis=1, keepdims=True)
            # images should be 2D so remove TZC
            agg.add_image(image_array.squeeze(axis=(0, 1, 4)))
    blurred_agg_img = agg.get_gaussian_image(30)
    assert blurred_agg_img is not None, "Failed to aggregated image"
    norm_img: npt.NDArray[Any] = blurred_agg_img / blurred_agg_img.mean()
    return norm_img


def random_timgs(image_array: npt.NDArray[Any]) -> list[npt.NDArray[Any]]:
    individual_images: list[npt.NDArray[Any]] = []
    num_images_to_select = min(
        10, image_array.shape[0]
    )  # Ensure we don't select more than available
    selected_indices = random.sample(
        range(image_array.shape[0]), num_images_to_select
    )
    individual_images.extend(
        image_array[index : index + 1] for index in selected_indices
    )
    return individual_images


def gen_example(
    conn: BlitzGateway,
    img_list: list[int],
    channel: int,
    mask: npt.NDArray[Any],
) -> list[tuple[npt.NDArray[Any], str]]:
    """
    Generates an example image that applies the flatfield correction mask.

    Args:
        conn: Connection to OMERO
        img_list: List of image IDs to use for generating the example.
        channel: Channel index.
        mask: Flatfield correction mask to apply to the image.

    Returns:
        List of tuples, each containing an image or image data and a title for that image or data.
    """
    random_id = random.choice(img_list)
    image = conn.getObject("Image", random_id)
    example_img = _generate_image(image, channel)
    scaled = _scale_img(example_img)
    corr_img = example_img / mask
    bgcorr_img = corr_img - np.percentile(corr_img, 0.2) + 1
    corr_scaled = _scale_img(bgcorr_img)
    # order all images for plotting
    return [
        (scaled, "original image"),
        (np.diagonal(example_img), "diag. intensities"),
        (corr_scaled, "corrected image"),
        (np.diagonal(corr_img), "diag. intensities"),
        (mask, "flatfield correction mask"),
    ]


def _scale_img(
    img: npt.NDArray[Any], percentile: tuple[float, float] = (1, 99)
) -> npt.NDArray[Any]:
    """Increase contrast by scaling image to exclude lowest and highest intensities"""
    percentiles = np.percentile(img, (percentile[0], percentile[1]))
    return exposure.rescale_intensity(img, in_range=tuple(percentiles))  # type: ignore


def _generate_image(image: ImageWrapper, channel: int) -> npt.NDArray[Any]:
    """Turn OMERO image object into numpy nd-array

    Args:
        image: OMERO image object
        channel: Channel number
    Returns:
        image
    """
    pixels = image.getPrimaryPixels()
    return pixels.getPlane(0, channel, 0)  # type: ignore


def example_fig(
    conn: BlitzGateway,
    data_list: list[tuple[npt.NDArray[Any], str]],
    channel: str,
    dataset_id: int,
) -> None:
    """
    Creates a figure from the given data list and uploads it to the OMERO server.

    Args:
        conn: Connection to OMERO
        data_list: List of tuples, each containing an image or image data and a title for that image or data.
        channel: Channel name
        dataset_id: ID of the dataset on the OMERO server to which the figure should be attached.
    """
    fig, ax = plt.subplots(1, 5, figsize=(20, 5))
    for i, data_tuple in enumerate(data_list):
        plt.sca(ax[i])
        if i in [0, 2, 4]:
            plt.imshow(data_tuple[0], cmap="gray")
        else:
            plt.plot(data_tuple[0])
            # TODO: what is this for?
            plt.ylim(0, 10 * data_tuple[0].min())
        plt.title(data_tuple[1])
    # save and close figure
    fig_id = f"{channel}_flatfield_check.pdf"  # using channel name
    fig.tight_layout()

    # Save the figure to a temporary file
    with tempfile.TemporaryDirectory() as temp_dir:
        tmp_path = os.path.join(temp_dir, fig_id)
        fig.savefig(tmp_path, format="pdf")
        plt.close(fig)

        # Assuming 'conn' is a BlitzGateway connection
        dataset = conn.getObject("Dataset", dataset_id)

        # Upload file to server
        file_ann = conn.createFileAnnfromLocalFile(
            tmp_path,
            mimetype="image/pdf",
        )
        dataset.linkAnnotation(file_ann)
